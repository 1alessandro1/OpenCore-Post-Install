{"./":{"url":"./","title":"OpenCore Post-Install","keywords":"","body":" Last modified: Fri Jul 10 2020 21:28:40 GMT+0000 (Coordinated Universal Time) OpenCore-Post-Install Welcome to the OpenCore Post-Install guide! Please note that if you have not installed macOS yet, we recommend you follow one of our install guides: OpenCore Desktop Guide OpenCore Laptop Guide And while the info here can be applied to both OpenCore and Clover, we primarily focus on OpenCore installations. So you will need to research a bit more if you run into any issues. How to follow this guide To start, not every section in this guide must be complete. It's up to each user whether they feel they want to add the finishing touches or resolve certain issues This guide is split into 4 parts: Universal All users are recommended to follow Laptop Specifics Laptop users are recommended to follow in addition to the above Cosmetics Cosmetics like OpenCore GUI and removing verbose screen output during boot Multiboot Recommendations for users who are multi-booting Miscellaneous Other misc fixes, not all users will require these fixes Universal Security and FileVault For those who care about security and privacy. Fixing Audio For those needing help resolving audio issues. Booting without USB Allowing you to boot OpenCore without the USB installed. Updating OpenCore, kexts and macOS How to update your kexts, OpenCore and even macOS safely. Fixing DRM For those with DRM issues like Netflix playback. Fixing iServices Help to fix misc iServices issues like iMessage. Fixing Power Management Fixes and helps improve both hardware idle and boosting states. Fixing USB Fixes for USB issues like missing ports and helping with sleep. Laptop Specifics Fixing Battery Read-outs If your battery isn't supported out of the box with SMCBatteryManager. Cosmetics Add GUI and Boot-chime Add a fancy GUI to OpenCore and even a boot chime! Fixing Resolution and Verbose Helps fix the resolution of OpenCore, and allows you to get that sweet Apple logo while booting! Multiboot Setting up Bootstrap.efi Ensures Windows doesn't remove OpenCore from our system. Installing BootCamp Allows us to install Bootcamp for easy boot switching. Miscellaneous Fixing RTC Helps resolve RTC/CMOS/safe-mode reboot issues. Fixing CFG Lock Allows use to remove some kernel patches for better stability Emulated NVRAM For users who have broken NVRAm, or need to test it. https://dortania.github.io/OpenCore-Post-Install/ "},"universal/security.html":{"url":"universal/security.html","title":"Security and FileVault","keywords":"","body":" Last modified: Fri Jul 10 2020 21:28:40 GMT+0000 (Coordinated Universal Time) Security and FileVault Supported version: 0.5.9 So something that makes OpenCore truly special is how it's been built with security in mind which is quite rare especially in the Hackintosh community. Well here we'll be going through and setting up some of OpenCore's great Security features: FileVault FileVault is macOS's builtin drive encryption, and with OpenCore support for it has been drastically improved compared to the legacy Clover drivers. To start, you'll need the following .efi drivers: OpenRuntime.efi OpenUsbKbDxe.efi for DuetPkg users(systems without UEFI support) Do not use VirtualSMC.efi with OpenCore, its already baked inside. You do however require VirtualSMC.kext still Setting in your config.plist: Misc -> Boot PollAppleHotKeys set to YES(While not needed can be helpful) Misc -> Security AuthRestart set to YES(Enables Authenticated restart for FileVault 2 so password is not required on reboot. Can be considered a security risk so optional) NVRAM -> Add -> 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14 UIScale set to 02 for high resolution small displays UEFI -> Input KeySupport set to YES(Only when using OpenCore's builtin input, users of OpenUsbKbDxe should avoid) UEFI -> Output ProvideConsoleGop to YES UEFI -> ProtocolOverrides FirmwareVolume set to YES HashServices set to YES for Broadwell and older(this includes X99), this is needed for systems with broken SHA-1 hashing AppleSmcIo set to YES(this replaces VirtualSMC.efi) UEFI -> Quirks RequestBootVarRouting set to YES ExitBootServicesDelay set to 3000-5000 if you receive Still waiting for root device on Aptio IV firmwares(Broadwell and older) With all this, you can proceed to enable FileVault like on a normal mac under System Preferences -> Security & Privacy -> FileVault For UI issues, see Fixing Resolution and Verbose Vault What is vaulting? Well vaulting is based around 2 things, vault.plist and vault.sig: vault.plist: a \"snapshot\" of your EFI vault.sig: validation of vault.plist This can be seen as secure boot for OpenCore, so no one can modify it and get in without your permission. The specifics of vaulting is that a 256 byte RSA-2048 signature of vault.plist will be shoved into our OpenCore.efi. This key can either be shoved into OpenCoreVault.c before compiling or with sign.command if you already have OpenCore.efi compiled. Do note that nvram.plist won't be vaulted so users with emulated NVRAM still have risk of someone adding/removing certain NVRAM variables Settings in your config.plist: Misc -> Security -> Vault: Basic: Requires just vault.plist to be present, mainly used for filesystem integrity verification Secure: Requires both vault.plist and vault.sig, used for best security as vault.plist changes require a new signature Booter -> ProtectSecureBoot: YES Needed with Insyde firmwares for fixing secure boot keys and reporting violations Setting up vault: Grab OpenCorePkg and open the CreateVault folder, inside we'll find the following: create_vault.sh RsaTool sign.command The last one is what we care about: sign.command So when we run this command, it'll look for the EFI folder located beside our Utilities folder, so we want to bring either our personal EFI into the OpenCorePkg folder or bring Utilities into our EFI folder: Now we're ready to run sign.command: Disabling Vault after setup: If you're doing heavy troubleshooting or have the need to disable Vault, the main things to change: Grab a new copy of OpenCore.efi Misc -> Security -> Vault set to Optional ScanPolicy What this quirk allows to prevent scanning and booting from untrusted sources. Setting to 0 will allow all sources present to be bootable but calculating a specific ScanPolicy value will allow you a greater range of flexibility and security. To calculate the ScanPolicy value, you simply add up all the hexadecimal values(with a hexadecimal calculator, you can access this from the built-in macOS calculator app with ⌘+3). Once it's all added up, you would add this hexadecimal value to ScanPolicy(you will need to convert it to a decimal value first, Xcode will automatically convert it when you paste it) 0x00000001 (bit 0) — OC_SCAN_FILE_SYSTEM_LOCK restricts scanning to only known file systems defined as a part of this policy. File system drivers may not be aware of this policy, and to avoid mounting of undesired file systems it is best not to load its driver. This bit does not affect dmg mounting, which may have any file system. Known file systems are prefixed with OCSCAN_ALLOW_FS. 0x00000002 (bit 1) — OC_SCAN_DEVICE_LOCK restricts scanning to only known device types defined as a part of this policy. This is not always possible to detect protocol tunneling, so be aware that on some systems it may be possible for e.g. USB HDDs to be recognized as SATA. Cases like this must be reported. Known device types are prefixed with OCSCAN_ALLOW_DEVICE. 0x00000100 (bit 8) — OC_SCAN_ALLOW_FS_APFS allows scanning of APFS file system. 0x00000200 (bit 9) — OC_SCAN_ALLOW_FS_HFS allows scanning of HFS file system. 0x00000400 (bit 10) — OC_SCAN_ALLOW_FS_ESP allows scanning of EFI System Partition file system. 0x00010000 (bit 16) — OC_SCAN_ALLOW_DEVICE_SATA allow scanning SATA devices. 0x00020000 (bit 17) — OC_SCAN_ALLOW_DEVICE_SASEX allow scanning SAS and Mac NVMe devices. 0x00040000 (bit 18) — OC_SCAN_ALLOW_DEVICE_SCSI allow scanning SCSI devices. 0x00080000 (bit 19) — OC_SCAN_ALLOW_DEVICE_NVME allow scanning NVMe devices. 0x00100000 (bit 20) — OC_SCAN_ALLOW_DEVICE_ATAPI allow scanning CD/DVD devices. 0x00200000 (bit 21) — OC_SCAN_ALLOW_DEVICE_USB allow scanning USB devices. 0x00400000 (bit 22) - OC_SCAN_ALLOW_DEVICE_FIREWIRE allow scanning FireWire devices. 0x00800000 (bit 23) — OC_SCAN_ALLOW_DEVICE_SDCARD allow scanning card reader devices. By default, ScanPolicy is given a value of 0xF0103(983,299) which is the combination of the following: OC_SCAN_FILE_SYSTEM_LOCK OC_SCAN_DEVICE_LOCK OC_SCAN_ALLOW_FS_APFS OC_SCAN_ALLOW_DEVICE_SATA OC_SCAN_ALLOW_DEVICE_SASEX OC_SCAN_ALLOW_DEVICE_SCSI OC_SCAN_ALLOW_DEVICE_NVME And lets just say for this example that you want to add OC_SCAN_ALLOW_DEVICE_USB: 0x00200000 + 0xF0103 = 0x2F0103 And converting this to decimal gives us 3,080,451 "},"universal/audio.html":{"url":"universal/audio.html","title":"Fixing Audio","keywords":"","body":" Last modified: Fri Jul 10 2020 21:28:40 GMT+0000 (Coordinated Universal Time) Fixing audio with AppleALC Supported version: 0.5.9 So to start, we'll assume you already have Lilu and AppleALC installed, if you're unsure if it's been loaded correctly you can run the following in terminal(This will also check if AppleHDA is loaded, as without this AppleALC has nothing to patch): kextstat | grep -E \"AppleHDA|AppleALC|Lilu\" If all 3 show up, you're good to go. And make sure VoodooHDA is not present. This will conflict with AppleALC otherwise. If you're having issues, see the Troubleshooting section Finding your layout ID So for this example, we'll assume your codec is ALC1220. To verify yours, you have a couple options: Checking motherboard's spec page and manual Check Device Manager in Windows Run cat in terminal on Linux cat /proc/asound/card0/codec#0 | less Now with a codec, we'll want to cross reference it with AppleALC's supported codec list: AppleALC Supported Codecs With the ALC1220, we get the following: 0x100003, layout 1, 2, 3, 5, 7, 11, 13, 15, 16, 21, 27, 28, 29, 34 So from this it tells us 2 things: Which hardware revision is supported(0x100003), only relevant when multiple revisions are listed with different layouts Various layout IDs supported by our codec(layout 1, 2, 3, 5, 7, 11, 13, 15, 16, 21, 27, 28, 29, 34) Now with a list of supported layout IDs, we're ready to try some out Note: If your Audio Codec is ALC 3XXX this is likely false and just a rebranded controller, do your research and see what the actual controller is. An example of this is the ALC3601, but when we load up Linux the real name is shown: ALC 671 Testing your layout To test out our layout IDs, we're going to be using the boot-arg alcid=xxx where xxx is your layout. Remember that to try layout IDs one at a time. Do not add multiple IDs or alcid boot-args, if one doesn't work then try the next ID and etc config.plist ├── NVRAM ├── Add ├── 7C436110-AB2A-4BBB-A880-FE41995C9F82 ├── boot-args | String | alcid=11 Making Layout ID more permanent Once you've found a Layout ID that works with your hack, we can create a more permanent solution for closer to how real macs set their Layout ID. With AppleALC, there's a priority hierarchy with which properties are prioritized: alcid=xxx boot-arg, useful for debugging and overrides all other values alc-layout-id in DeviceProperties, should only be used on Apple hardware layout-id in DeviceProperties, should be used on both Apple and non-Apple hardware To start, we'll need to find out where our Audio controller is located on the PCI map. For this, we'll be using a handy tool called gfxutil then with the macOS terminal: path/to/gfxutil -f HDEF Then add this PciRoot with the child layout-id to your config.plist under DeviceProperties -> Add: Note that AppleALC can accept both Decimal/Number and Hexadecimal/Data, generally the best method is Hex as you avoid any unnecessary conversions. You can use a simple decimal to hexadecimal calculator to find yours. printf '%x\\n' DECI_VAL: So in this example, alcid=11 would become either: layout-id | Data | layout-id | Number | Note that the final HEX/Data value should be 4 bytes in total(ie. 0B 00 00 00 ), for layout IDs surpassing 255(FF 00 00 00) will need to remember that the bytes are swapped. So 256 will become FF 01 00 00 HEX Swapping and data size can be completely ignored using the Decimal/Number method Reminder: You MUST remove the boot-arg afterwards, as it will always have the top priority and so AppleALC will ignore all other entries like in DeviceProperties Miscellaneous issues No Mic on AMD: This is a common issue with when running AppleALC with AMD, specifically no patches have been made to support Mic input. At the moment the \"best\" solution is to either buy a USB DAC/Mic or go the VoodooHDA.kext method. Problem with VoodooHDA is that it's been known to be unstable and have worse audio quality than AppleALC Same layout ID from Clover doesn't work on OpenCore: This is likely do to IRQ conflicts, on Clover there's a whole sweep of ACPI hot-patches that are applied automagically. Fixing this is a little bit painful but SSDTTime's FixHPET option can handle most cases. For odd cases where RTC and HPET take IRQs from other devices like USB and audio, you can reference the HP Compaq DC7900 ACPI patch example in the trashOS repo Kernel Panic on power state changes in 10.15: Enable PowerTimeoutKernelPanic in your config.plist: Kernel -> Quirks -> PowerTimeoutKernelPanic -> True Alternatively you can use setpowerstate_panic=0 in boot-args, which is the equivalent of the above quirk. Troubleshooting So for troubleshooting, we'll need to go over a couple things: Checking if you have the right kexts Checking if AppleALC is patching correctly Checking AppleHDA is vanilla AppleALC working inconsistently Checking if you have the right kexts To start, we'll assume you already have Lilu and AppleALC installed, if you're unsure if it's been loaded correctly you can run the following in terminal(This will also check if AppleHDA is loaded, as without this AppleALC has nothing to patch): kextstat | grep -E \"AppleHDA|AppleALC|Lilu\" If all 3 show up, you're good to go. And make sure VoodooHDA is not present. This will conflict with AppleALC otherwise. Other kexts to make sure you do not have in your system: realtekALC.kext CloverALC.kext VoodooHDA.kext HDA Blocker.kext HDAEnabler#.kext(# can be 1, 2, or 3) Hey Lilu and/or AppleALC aren't showing up Generally the best place to start is by looking through your OpenCore logs and seeing if Lilu and AppleALC injected correctly: 14:354 00:020 OC: Prelink injection Lilu.kext () - Success 14:367 00:012 OC: Prelink injection AppleALC.kext () - Success If it says failed to inject: 15:448 00:007 OC: Prelink injection AppleALC.kext () - Invalid Parameter Main places you can check as to why: Injection order: Make sure that Lilu is above AppleALC in kext order All kexts are latest release: Especially important for Lilu plugins, as mismatched kexts can cause issues Note: To setup file logging, see OpenCore Debugging. Checking if AppleALC is patching correctly So with AppleALC, one of the most easiest things to check if the patching was done right was to see if your audio controller was renamed correctly. Grab IORegistryExplorer and see if you have an HDEF device: As you can see from the above image, we have the following: HDEF Device meaning our rename did the job AppleHDAController attached meaning Apple's audio kext attached successfully alc-layout-id is a property showing our boot-arg/DeviceProperty injection was successful Note: layout-id | Data | 07000000 is the default layout, and alc-layout-id will override it and be the layout AppleHDA will use Note: Do not rename your audio controller manually, this can cause issues as AppleALC is trying to patch already. Let AppleALC do it's work. More examples: Correct layout-id Incorrect layout-id As you can see from the above 2, the right image is missing a lot of AppleHDAInput devices, meaning that AppleALC can't match up your physical ports to something it can understand and output to. This means you've got some work to find the right layout ID for your system. Checking AppleHDA is vanilla This section is mainly relevant for those who were replacing the stock AppleHDA with a custom one, this is going to verify whether or not yours is genuine: sudo kextcache -i / && sudo kextcache -u / This will check if the signature is valid for AppleHDA, if it's not then you're going to need to either get an original copy of AppleHDA for your system and replace it or update macOS(kexts will be cleaned out on updates). This will only happen when you're manually patched AppleHDA so if this is a fresh install it's highly unlikely you will have signature issues. AppleALC working inconsistently Sometimes race conditions can occur where your hardware isn't initialized in time for AppleHDAController resulting in no sound output. To get around this, you can either: Specify in boot-args the delay: alcdelay=1000 Or Specify via DeviceProperties(in your HDEF device): alc-delay | Number | 1000 The above boot-arg/property will delay AppleHDAController by 1000 ms(1 second), note the ALC delay cannot exceed 3000 ms "},"universal/oc2hdd.html":{"url":"universal/oc2hdd.html","title":"Booting without USB","keywords":"","body":" Last modified: Fri Jul 10 2020 21:28:40 GMT+0000 (Coordinated Universal Time) Moving OpenCore from USB to macOS Drive Supported version: 0.5.9 Grabbing OpenCore off the USB So to start, we'll first want to grab OpenCore off of our installer. To do this, we'll be using a neat tool from CorpNewt called MountEFI For this example, we'll assume your USB is called Install macOS Catalina: Once the EFI's mounted, we'll want to grab our EFI folder on there and keep in a safe place. We'll then want to eject the USB drive's EFI as having multiple EFI's mounted can confuse macOS sometimes, best practice is to keep only 1 EFI mounted at a time(you can eject just the EFI, the drive itself doesn't need to be removed) Note: Installers made with gibMacOS's MakeInstall.bat on Windows will default to a Master Boot Record(MBR) partition map, this means there is no dedicated EFI partition instead being the BOOT partition that mounts by default in macOS. Now with this done, lets mount our macOS drive. With macOS Catalina, macOS is actually partitioned into 2 volumes: System Partition and User Partition. This means that MountEFI may report multiple drives in it's picker but each partition will still share the same EFI(The UEFI spec only allows for 1 EFI per drive). You can tell if it's the same drive with diskXsY (Y is just to say what partition it is) When you mount your main drive's EFI, you may be greeted with a folder called APPLE, this is used for updating the firmware on real Macs but has no effect on our hardware. You can wipe everything on the EFI partition and replace it with the one found on your USB Special notes for legacy users When transferring over your EFI, there are still boot sectors that need to be written to so your non-UEFI BIOS would be able to find it. So don't forget to rerun the BootInstall.command on your macOS drive "},"universal/update.html":{"url":"universal/update.html","title":"Updating OpenCore, kexts and macOS","keywords":"","body":" Last modified: Fri Jul 10 2020 21:28:40 GMT+0000 (Coordinated Universal Time) Updating OpenCore and macOS Supported version: 0.5.9 Updating OpenCore So the main things to note with updating OpenCore: Releases happen the first Monday of every month The Differences.pdf will tell you all the things added and removed from this version of OpenCore compared to the previous release The OpenCore Vanilla Guide will have a note on the README.md about what release version it supports So how do I update? So the process goes as follows: Download the latest release of OpenCore OpenCorePkg Mount your EFI So first, lets mount your hard drive's EFI and make a copy somewhere safe with MountEFI. We won't be updating the drive's EFI at first, instead we'll be grabbing a spare USB to be our crash dummy. This allows us to keep a working copy of OpenCore in case our update goes south For the USB, it must be formatted as GUID. Reason for this is that GUID will automatically create an EFI partition, though this will be hidden by default so you'll need to mount it with MountEFI. Now you can place your OpenCore EFI on the USB Replace the OpenCore files with the ones you just downloaded The important ones to update: EFI/BOOT/BOOTx64.efi EFI/OC/OpenCore.efi EFI/OC/Drivers/OpenRuntime(Don't forget this one, OpenCore will not boot with mismatched versions) You can also update other drivers you have if present, these are just the ones that must be updated in order to boot correctly Compare your config.plist to that of the new Sample.plist With this, there's a couple ways to do this: OCConfigCompare to compare between the sample.plist and your config.plist diff (file input 1) (file input 2) in terminal BeyondCompare Make a new config based off reading the updated OpenCore Vanilla Guide Once you've made the adjustments and made sure you config is compliant with the newest release of OpenCore, make sure to double check your setting with the OpenCore Guide on what to set everything to, otherwise read the Differences.pdf if you want to get a bit more technical. Boot! Once everything's working with the dummy USB, you can mount the EFI and move it over to the hard drive's EFI partition. Remember to keep a copy of your old EFI in cases where OpenCore is acting funny down the road Updating Kexts Updating Kexts is a similar process to updating OpenCore, make a copy of everything and update on a dummy USB in case there's issues The easiest way to update your kexts is via 2 tools: Lilu and Friends to download and compile the kexts Kext Extractor to merge them into your EFI Updating macOS So this is probably one of the most challenging parts, maintaining your system through OS updates. The main things to keep in mind: With OS updates, make sure everything has been updated and you have some form of recovery like TimeMachine or an older macOS installer with a known good EFI on it Do a bit of google-fu to see if others are having issues with the newest update I've also provided a bit more of a detailed map of what's changed in macOS versions, see below: macOS Catalina 10.15.0 Requires proper EC Dual socket and most AMD CPUs need AppleMCEReporterDisabler.kext MacPro5,1 support has been dropped 10.15.1 Requires WhateverGreen 1.3.4+ Broke DRM for many GPUs(see DRM Chart) Requires all previous fixes 10.15.2 Fixes Navi support in the installer Requires all previous fixes 10.15.3 No change Requires all previous fixes 10.15.4 AMD CPU users need to update cpuid_set_cpufamily patch Fixes DRM on many Ellesmere based Polaris GPUs Requires all previous fixes(excluding shikigva=80 for Polaris DRM for most users) 10.15.5 UHD 630's framebuffer broke for many, if you receive black screen you may need to swap from 07009B3E to 00009B3E Comet Lake S no longer requires a CPU ID spoof "},"universal/drm.html":{"url":"universal/drm.html","title":"Fixing DRM","keywords":"","body":" Last modified: Fri Jul 10 2020 21:28:40 GMT+0000 (Coordinated Universal Time) Fixing DRM support and iGPU performance Supported version: 0.5.9 So with DRM, we have a couple things we need to mention: DRM requires a supported dGPU See the GPU Buyers Guide for supported cards DRM is broken for iGPU-only systems These have never worked with Haswell and newer For Ivy Bridge, this could be fixed with Shiki (now WhateverGreen) til 10.12.2, but broke with 10.12.3 Working hardware acceleration and decoding Testing Hardware Acceleration and Decoding So before we can get started with fixing DRM, we need to make sure your hardware is working. The best way to check is by running VDADecoderChecker: If you fail at this point, there's a couple things you can check for: Make sure your hardware is supported See GPU Buyers Guide Make sure the SMBIOS you're running matches with your hardware Don't use a Mac Mini SMBIOS on a desktop for example, as Mac Minis run mobile hardware and so macOS will expect the same Make sure the iGPU is enabled in the BIOS and has the correct properties for your setup (AAPL,ig-platform-id and if needed, device-id) You can either review the DeviceProperties section from the guide or WhateverGreen's manual Avoid unnecessary ACPI renames, all important ones are handled in WhateverGreen change GFX0 to IGPU change PEG0 to GFX0 change HECI to IMEI etc Make sure Lilu and WhateverGreen are loaded Make sure not to have any legacy graphics patches present as they've been absorbed into WhateverGreen: IntelGraphicsFixup.kext NvidiaGraphicsFixup.kext Shiki.kext To check if Lilu and WhateverGreen loaded correctly: kextstat | grep -E \"Lilu|WhateverGreen\" Hey one or more of these kexts aren't showing up Generally the best place to start is by looking through your OpenCore logs and seeing if Lilu and WhateverGreen injected correctly: 14:354 00:020 OC: Prelink injection Lilu.kext () - Success 14:367 00:012 OC: Prelink injection WhateverGreen.kext () - Success If it says failed to inject: 15:448 00:007 OC: Prelink injection WhateverGreen.kext () - Invalid Parameter Main places you can check as to why: Injection order: Make sure that Lilu is above AppleALC in kext order All kexts are latest release: Especially important for Lilu plugins, as mismatched kexts can cause issues Note: To setup file logging, see OpenCore Debugging. Note: On macOS 10.15 and newer, AppleGVA debugging is disabled by default, if you get a generic error while running VDADecoderChecker you can enable debugging with the following: defaults write com.apple.AppleGVA enableSyslog -boolean true And to undo this once done: defaults delete com.apple.AppleGVA enableSyslog Testing DRM So before we get too deep, we need to go over some things, mainly the types of DRM you'll see out in the wild: FairPlay 1.x: Software based DRM, used for supporting legacy Macs more easily Easiest way to test this is by playing an iTunes movie: FairPlay 1.x test FairPlay 1.x trailers will work on any configuration if WhateverGreen is properly set up - including iGPU-only configurations. However, FairPlay 1.x movies will only play on iGPU-only configurations for around 3-5 seconds, erroring that HDCP is unsupported afterwards. FairPlay 2.x/3.x: Hardware based DRM, found in Netflix, Amazon Prime There's a couple ways to test: Play a show in Netflix or Amazon Prime Play an Amazon Prime trailer: Spider-Man: Far From Home Trailer itself does not use DRM but Amazon still checks before playing Note: Requires newer AMD GPU to work (Polaris+) FairPlay 4.x: Mixed DRM, found on AppleTV+ You can open TV.app, choose TV+ -> Free Apple TV+ Premieres, then click on any episode to test without any trial (you do need an iCloud account) Apple TV+ also has a free trial if you want to use it Note: Requires either an absent iGPU (Xeon) or newer AMD GPU to work (Polaris+) Possible to force FairPlay 1.x when iGPU is absent If everything works on these tests, you have no need to continue! Otherwise, proceed on. Fixing DRM So for fixing DRM we can go down mainly 1 route: patching DRM to use either software or AMD decoding. Vit made a great little chart for different hardware configurations: WhateverGreen's DRM chart So how do you use it? First, identify what configuration you have in the chart (AMD represents GPU, not CPU). The SMBIOS listed (IM = iMac, MM = Mac Mini, IMP = iMac Pro, MP = Mac Pro) is what you should use if you match the hardware configuration. If you don't match any of the configurations in the chart, you're out of luck. Next, identify what Shiki mode you need to use. If there are two configurations for your setup, they will differ in the Shiki flags used. Generally, you want hardware decoding over software decoding. If the mode column is blank, then you are done. Otherwise, you should add shikigva as a property to any GPU, using DeviceProperties > Add. For example, if the mode we need to use is shikigva=80: You can also use the boot argument - this is in the mode column. Here's one example. If we have an Intel i9-9900K and an RX 560, the configuration would be \"AMD+IGPU\", and we should be using an iMac or Mac Mini SMBIOS (for this specific configuration, iMac19,1). Then we see there are two options for the configuration: one where the mode is shikigva=16, and one with shikigva=80. We see the difference is in \"Prime Trailers\" and \"Prime/Netflix\". We want Netflix to work, so we'll choose the shikigva=80 option. Then inject shikigva with type number/integer and value 80 into our iGPU or dGPU, reboot, and DRM should work. Here's another example. This time, We have an Ryzen 3700X and an RX 480. Our configuration in this case is just \"AMD\", and we should be using either an iMac Pro or Mac Pro SMBIOS. Again, there are two options: no shiki arguments, and shikigva=128. We prefer hardware decoding over software decoding, so we'll choose the shikigva=128 option, and again inject shikigva into our dGPU, this time with value 128. A reboot and DRM works. Notes: You can use gfxutil to find the path to your iGPU/dGPU. path/to/gfxutil -f GFX0 GFX0: For dGPUs, if multiple installed check IORegistryExplorer for what your AMD card is called IGPU: For iGPU If you inject shikigva using DeviceProperties, ensure you only do so to one GPU, otherwise WhateverGreen will use whatever it finds first and it is not guaranteed to be consistent. IQSV stands for Intel Quick Sync Video: this only works if iGPU is present and enabled and it is set up correctly. Special configurations (like Haswell + AMD dGPU with an iMac SMBIOS, but iGPU is disabled) are not covered in the chart. You must do research on this yourself. Shiki source is useful in understanding what flags do what and when they should be used, and may help with special configurations. Fixing iGPU performance So how do we fix iGPU performance? Well by loading Apple's GuC (Graphics Micro Code). The main thing to note is that firmware loading is restricted to: Skylake and newer CPU with a supported iGPU And a recent chipset, 300-series or newer: Z390, B360, H370, H310, etc. (not Z370, as it is actually 200-series) Do note that even with recent chipsets, firmware loading is not guaranteed to work. If you experience a kernel panic or lots of graphics errors after trying this, it is probably because firmware loading is not supported on your setup. So how do we apply it? Under DeviceProperties -> Add -> PciRoot(0x0)/Pci(0x2,0x0), add: igfxfw | Data | To enable firmware loading. The best way to check is to monitor the iGPU's frequency is with either Intel Power Gadget or checking the boot logs for Apple Scheduler references. Make sure you have the igfxfw property applied: kernel: (AppleIntelCFLGraphics) [IGPU] Graphics Firmware Version: 2.14.0.0 kernel: (AppleIntelCFLGraphics) [IGPU] Graphics Firmware Version: 2.14.0.0 kernel: (AppleIntelCFLGraphics) [IGPU] Graphics accelerator is using scheduler: Apple Firmware kernel: (AppleIntelCFLGraphics) [IGPU] Graphics accelerator is using scheduler: Apple Firmware "},"universal/iservices.html":{"url":"universal/iservices.html","title":"Fixing iServices","keywords":"","body":" Last modified: Fri Jul 10 2020 21:28:40 GMT+0000 (Coordinated Universal Time) Fixing iMessage and other services with OpenCore Supported version: 0.5.9 This page is for those having iMessage and other iServices issues, this is a very basic guide so will not go as in-depth into the issues as some other guides. This specific guide is a translation and reinterpretation of the AppleLife Guide on fixing iServices: Как завести сервисы Apple - iMessage, FaceTime, iCloud Note: You and you alone are responsible for your AppleID, read the guide carefully and take full responsibility if you screw up. Dortania and other guides are not held accountable for what you do. Generate a new Serial Download GenSMBIOS and select option 1 to download MacSerial and next option 3 to generate some new serials. What we're looking for is a valid serial that currently has no registered purchase date. Tip: iMacPro1,1 10 will print 10 serials, this will save you some time on generating Now enter the serial into the Apple Check Coverage page, you will get 1 of 3 responses: We’re sorry, but this serial number isn’t valid Valid Purchase date Purchase Date not Validated This last one is what we're after, as we want something genuine but currently not in use by anyone. Now we can translate the rest of the values into our config.plist -> PlatformInfo -> Generic: Type = SystemProductName Serial = SystemSerialNumber Board Serial = MLB SmUUID = SystemUUID Note: \"We’re sorry, but this serial number isn’t valid. Please check your information and try again.\" works for many users as well, do note though if you've had a bad track record with Apple/iServices you many need one that's \"Purchase Date not Validated\". Otherwise there may be suspicion Note 2: Using a \"Purchase Date not Validated:\" can cause issues down the line if another machine of the same serial ever gets activated, for initial setup it can help alleviate issues with your account but in the long run an invalid serial can be a safer choice. Note3: Checking too many serials may result in your access being denied to Apple Check Coverage page, to bypass this limitation it's advised to use a VPN or tor browser or any other service that allows you to change/mask your IP address. Fixing En0 To start, grab Hackintool (Github link) and head to System -> Peripherals (Info -> Misc on older versions of Hackintool) Here under Network Interfaces (network card icon), look for en0 under BSD and check whether the device has a check mark under Builtin. If there is a check mark, skip to Fixing ROM section otherwise continue reading. Note: en0 can be either Wifi, ethernet or even Thunderbolt. What if I don't have En0 at all?!? Well, we'll want to reset macOS so it can build the interfaces fresh, open terminal and run the following: sudo rm /Library/Preferences/SystemConfiguration/NetworkInterfaces.plist sudo rm /Library/Preferences/SystemConfiguration/preferences.plist Once done reboot and check again. If this doesn't work, add NullEthernet.kext and ssdt-rmne.aml to your EFI and config.plist under Kernel -> Add and ACPI -> Add respectively. The SSDT is precompiled so no extra work needed, reminder compiled files have a .aml extension and .dsl can be seen as source code. Now head under the PCI tab of Hackintool and export your PCI DeviceProperties, this will create a pcidevices.plist on your desktop Now search through the pcidevices.plist and find the PciRoot of your ethernet controller. For us, this would be PciRoot(0x0)/Pci(0x1f,0x6) Now with the PciRoot, go into your config.plist -> DeviceProperties -> Add and apply the property of built-in with type Data and value 01 Fixing ROM This is a section many may have forgotten about but this is found in your config.plist under PlatformInfo -> generic -> ROM To find your actual MAC Address/ROM value, you can find in a couple places: BIOS macOS: System Preferences -> Network -> Ethernet -> Advanced -> MAC Address Windows: Settings -> Network & Internet -> Ethernet -> Ethernet -> Physical MAC Address Note: en0 can be either Wifi, ethernet or even Thunderbolt, adapt the above example to your situation. Some users have even gone as far as using real Apple MAC Address dumps for their config, for this guide we'll be using our real MAC Address but note that this is another option. When adding this to your config, c0:7e:bf:c3:af:ff should be converted to c07ebfc3afff as the Data type cannot accept colons(:). Verifying NVRAM Something that many forget about iServices is that NVRAM is crucial to getting it working correctly, the reason being is that iMessage keys and such are stored in NVRAM. Without NVRAM, iMessage can neither see nor store keys. So we'll need to verify NVRAM works, regardless if \"it should work\" as some firmwares can be more of a pain than others. Please refer to the Emulated NVRAM section of the OpenCore Guide for both testing if you have working NVRAM and emulating it if you don't. Clean out old attempts This is important for those who've tried setting up iMessage but failed, to start make sure your NVRAM has been cleared. You can enable the option in the boot picker in your config under config.plist -> Misc -> Security -> AllowNvramReset. Next open terminal and run the following: sudo rm -rf ~/Library/Caches/com.apple.iCloudHelper* sudo rm -rf ~/Library/Caches/com.apple.Messages* sudo rm -rf ~/Library/Caches/com.apple.imfoundation.IMRemoteURLConnectionAgent* sudo rm -rf ~/Library/Preferences/com.apple.iChat* sudo rm -rf ~/Library/Preferences/com.apple.icloud* sudo rm -rf ~/Library/Preferences/com.apple.imagent* sudo rm -rf ~/Library/Preferences/com.apple.imessage* sudo rm -rf ~/Library/Preferences/com.apple.imservice* sudo rm -rf ~/Library/Preferences/com.apple.ids.service* sudo rm -rf ~/Library/Preferences/com.apple.madrid.plist* sudo rm -rf ~/Library/Preferences/com.apple.imessage.bag.plist* sudo rm -rf ~/Library/Preferences/com.apple.identityserviced* sudo rm -rf ~/Library/Preferences/com.apple.ids.service* sudo rm -rf ~/Library/Preferences/com.apple.security* sudo rm -rf ~/Library/Messages Verifying your work one last time Grab macserial and run the following: path/to/macserial -s This will provide us with a full rundown of our system, verify that what is presented matches up with your work. Cleaning up your AppleID Remove all devices from your AppleID: Manage your devices Enable 2 Factor-Auth Remove all iServices from Keychain, some examples: ids: identity-rsa-key-pair-signature-v1 ids: identity-rsa-private-key ids: identity-rsa-public-key ids: message-protection-key ids: message-protection-public-data-registered ids: personal-public-key-cache iMessage Encryption Key iMessage Signing Key com.apple.facetime: registrationV1 etc ... And a final layer of precaution is to make a new AppleID to play with, this makes sure that if you do end up blacklisting your account that it's not your main. Tip: Adding a payment card to the account and having a decent amount of purchases can also help. While not concrete, you can think of an AppleID as a credit score where the better an Apple customer you are the more likely they won't have activation issues or get an easier pass with AppleSupport Customer Code error Welp mate, you've done it. You blackmailed your AppleID. The fix is simple but not pretty, you MUST call Apple. Otherwise, there is no proceeding besides using a new account. Adding a payment card before calling can help legitimize the account so it doesn't seem as much like a bot. "},"universal/pm.html":{"url":"universal/pm.html","title":"Fixing Power Management","keywords":"","body":" Last modified: Fri Jul 10 2020 21:28:40 GMT+0000 (Coordinated Universal Time) Optimizing Power Management Enabling X86PlatformPlugin So before we can fine tune power management to our liking, we need to first make sure Apple's XCPM core is loaded. Note that this is supported only on Haswell and newer, Sandy and Ivy Bridge should refer to the bottom of the guide: Sandy and Ivy Bridge Power Management. To start, grab IORegistryExplorer and look for AppleACPICPU(note if you use search, it won't show the children so clear your search once you've found the entry): XCPM Present Missing XCPM As you can see from the left image, we have the X86PlatformPlugin attached meaning Apple's CPU Power Management Drivers are doing their thing. If you get something like to the right image, then there's likely an issue. Make sure to check the following: SSDT-PLUG.aml is both present and enabled in your config.plist and EFI/OC/ACPI If you're missing this, head to Getting Started With ACPI on how to make this SSDT-PLUG is set to the first thread of your CPU, you can check by selecting the first CPU listed(CP00 for our example) and make sure you have this in the properties: plugin-type | Number | 0x1 X99 Note: XCPM does not natively support Haswell-E and Broadwell-E, this means we need to spoof the CPU ID into a model that does supports XCPM: Haswell E: Kernel -> Emulate: Cpuid1Data﻿: C3060300 00000000 00000000 00000000 Cpuid1Mask: FFFFFFFF 00000000 00000000 00000000 Broadwell-E: Kernel -> Emulate: Cpuid1Data﻿: D4060300﻿ 00000000 00000000 00000000 Cpuid1Mask: FFFFFFFF 00000000 00000000 00000000 Using CPU Friend To start, we're gonna need a couple things: X86PlatformPlugin loaded CPUFriend CPUFriendFriend Now lets run CPUFriendFriend.command The min hex freq should be what the lowest possible TDP for the CPU, on Intel's ARK site search for TDP-down Frequency and convert this value to HEX. Note that not all CPUs support TDP-down Frequency, like the i7-9700T vs i7 9700. In these scenarios, you'll want to do a bit more research into your CPU, specifically: Minimum Multiplier (Generally stable with x10 on Intel's consumer platform) FSB (Front Side Bus Frequency, this is 100MHz on most CPUs) LPM = MinMultiplier x FSB For this example we'll be using the i9 7920x which has a base clock of 2.9 GHz but no LPM, so we'll choose 1.3 GHz(13x100) and work our way up/down until we find stability. Note: Mobile SMBIOS will likely have several Frequency Vectors, this is for how many steps your CPU will take. On the MacBook9,1 SMBIOS for example, we get 3 Frequency Vectors. So the idea is: Lowest frequency macOS will idle at(ie. sitting at the desktop) Middle frequency for simple tasks(ie. text editing or using the finder) Average frequency for little more demanding tasks(ie. Safari, Youtube, etc) The last frequency is not your maximum frequency so don't worry about being capped at that limit. echo \"obase=16; 13\" | bc Next up is the Energy Performance Preference, EPP. This tells macOS how fast to turbo up the CPU to its full clock. 00 will tell macOS to let the CPU go as fast as it can as quickly as it can while FF will tell macOS to take things slowly and let the CPU ramp up over a much longer period of time. Depending on what you're doing and the cooling on your machine, you may want to set something in the middle. Below chart can help out a bit: EPP Speed 0x00-0x3F Max Performance 0x40-0x7F Balance performance 0x80-0xBF Balance power 0xC0-0xFF Max Power Saving Note: Only Skylake and newer SMBIOS officially support EPP Once you're finished, you'll be provided with a CPUFriendDataProvider.kext and ssdt_data.aml. Which you choose is your preference but I recommend the kext variant to avoid any headaches with data injection into Windows and Linux. Note: Load order does not matter with the CPUFriendDataProvider as it's just a plist-only kext Note 2: Wake issues resulting from CPUFriend is likely due to incorrect frequency vectors, every system is unique so you'll need to play around until you get a stable config. Kernel panics will have Sleep Wake failure in efi. Sandy and Ivy Bridge Power Management With Sandy and Ivy Bridge, consumer PCs have issues connecting to Apple's XCPM. So to get around this we need to create our own Power Management Table. What we'll need: CpuPm and Cpu0Ist tables dropped ssdtPRGen To drop the CpuPm and Cpu0Ist tables, head to ACPI -> Delete: Key Type Value All Boolean YES Comment String Drop CpuPm Enabled Boolean YES OemTableId Data 437075506d000000 TableLength Number 0 TableSignature Data 53534454 Key Type Value All Boolean YES Comment String Drop Cpu0Ist Enabled Boolean YES OemTableId Data 4370753049737400 TableLength Number 0 TableSignature Data 53534454 Once this is done, we can now grab ssdtPRGen and run it: Once you're done, you'll be provided with an SSDT.aml under /Users/your-name>/Library/ssdtPRGen/ssdt.dsl, you can easily find it with the Cmd+Shift+G shortcut and pasting ~/Library/ssdtPRGen/ Remember to now add this to both EFI/OC/ACPI and your config.plist, I recommend renaming it to SSDT-PM to find it more easily "},"laptop-specific/battery.html":{"url":"laptop-specific/battery.html","title":"Fixing Battery Read-outs","keywords":"","body":" Last modified: Fri Jul 10 2020 21:28:40 GMT+0000 (Coordinated Universal Time) Battery Patching While at the moment battery patching is not something covered in this guide, we'll at least point you to some helpful resources and add some useful notes for when using them in OpenCore. DSDT Patching While custom DSDT injection should be avoided as to prevent issues with Windows and firmware updates, it can be quite helpful as a starting point since it's a bit easier to grasp and do yourself: Rehabman's how to patch DSDT for working battery status Note: When re-injecting your DSDT, it should be the first in the list of ACPI -> Add in the config.plist. And also remember that the patched DSDT would also go into EFI/OC/ACPI Note 2: Avoid using the MaciASL and iASL provided by Rehabman, they have been long neglected and so highly recommended grabbing a newer variant from Acidanthera: MaciASL Battery Hot-patching Once you've finally gotten your DSDT patched and battery working in macOS, it's time to finally create our very own hot-patches. How these differ from regular DSDT patching is that it's done on the fly with the DSDT allowing for greater flexibility with firmware updates: Rehabman's Guide to Using Clover to \"hotpatch\" ACPI Note: Specifically post #2 refers to battery hot-patching "},"cosmetic/gui.html":{"url":"cosmetic/gui.html","title":"Add GUI and Boot-chime","keywords":"","body":" Last modified: Fri Jul 10 2020 21:28:40 GMT+0000 (Coordinated Universal Time) OpenCore beauty treatment Supported version: 0.5.9 Main thing this guide will go over: Giving OpenCore a GUI Setting up a boot-chime Setting up OpenCore's GUI So to get started, we're gonna need 0.5.7 or newer as these builds have the GUI included with the rest of the files. If you're on an older version, I recommend updating: Updating OpenCore Once that's done, we'll need a couple things: Binary Resources OpenCanopy.efi Note: OpenCanopy.efi must be from the same build as your OpenCore files, as mismatched files can cause boot issues Once you have both of these, we'll next want to add it to our EFI partition: Add the Resources folder to EFI/OC Add OpenCanopy.efi to EFI/OC/Drivers Now in our config.plist, we have 2 things we need to fix: Misc -> Boot -> PickerMode: External Misc -> Boot -> PickerAttributes:1 This enables .VolumeIcon.icns reading off the drive, this is how macOS installer icons work 0x0008: This is another value which allows for alternative icons, such as the legacy GUI found on legacy Macs. This can be combined with 1 for both legacy GUI and custom drive icons(PickerAttributes: 9) Other settings for PickerAttributes can be found in the Configuration.pdf UEFI -> Drivers and add OpenCanopy.efi Once all this is saved, you can reboot and be greeted with a true Mac-like GUI: Setting up Boot-chime with AudioDxe So to start, we'll need a couple things: Onboard audio output USB DACs will not work GPU audio out is a hit or miss AudioDxe in both EFI/OC/Drivers and UEFI -> Drivers Binary Resources Add the Resources folder to EFI/OC, just like we did with the OpenCore GUI section For those running out of space, OCEFIAudio_VoiceOver_Boot.wav is all that's required for the Boot-Chime Debug version of OpenCore with logging enabled See OpenCore Debugging for more info Settings up NVRAM: NVRAM -> Add -> 7C436110-AB2A-4BBB-A880-FE41995C9F82: SystemAudioVolume | Data | 0x46 This is the boot-chime and screen reader volume, note it's in hexadecimal so would become 70 in decimal Setting up UEFI -> Audio: AudioCodec: Codec address of Audio controller To find yours: Check IORegistryExplorer -> HDEF -> AppleHDAController -> IOHDACodecDevice and see the IOHDACodecAddress property ex: 0x0 Can also check via terminal(Note if multiple show up, use the vendor ID to find the right device)l: ioreg -rxn IOHDACodecDevice | grep VendorID // List all possible devices ioreg -rxn IOHDACodecDevice | grep IOHDACodecAddress // Grab the codec address Audio Device: PciRoot of audio controller Run gfxutil to find the path: /path/to/gfxutil -f HDEF ex: PciRoot(0x0)/Pci(0x1f,0x3) AudioOut: The specific output of your Audio controller, easiest way to find the right one is to go through each one(from 0 to N - 1) ex: 2 You can find all the ones for your codec in the OpenCore debug logs: 06:065 00:004 OCAU: Matching PciRoot(0x0)/Pci(0x1F,0x3)/VenMsg(A9003FEB-D806-41DB-A491-5405FEEF46C3,00000000)... 06:070 00:005 OCAU: 1/2 PciRoot(0x0)/Pci(0x1F,0x3)/VenMsg(A9003FEB-D806-41DB-A491-5405FEEF46C3,00000000) (5 outputs) - Success AudioSupport: Set this to True MinimumVolume: Volume level from 0 to 100 To not blow the speakers, set it to 70 Note boot-chime will not play if MinimumVolume is higher than SystemAudioVolume that we set back in the NVRAM section PlayChime: Set this to True VolumeAmplifier: The Volume amplification, value will differ depending on your codec Formula is as follows: (SystemAudioVolume * VolumeAmplifier)/100 = Raw Volume(but cannot exceed 100) ex: (70 x VolumeAmplifier)/100 = 100 -> (100 x 100) / 70 = VolumeAmplifier = 142.9(we'll round it to 143 for simplicity) Once done, you should get something like this: Note for visually impaired: OpenCore hasn't forgotten about you! With the AudioDxe setup, you can enable both picker audio and FileVault VoiceOver with these 2 settings: Misc -> Boot -> PickerAudioAssist -> True to enable picker audio UEFI -> ProtocolOverrides -> AppleAudio -> True to enable FileVault voice over See Security and FileVault on how to setup the rest for proper FileVault support "},"cosmetic/verbose.html":{"url":"cosmetic/verbose.html","title":"Fixing Resolution and Verbose","keywords":"","body":" Last modified: Fri Jul 10 2020 21:28:40 GMT+0000 (Coordinated Universal Time) Fixing Resolution and Verbose Supported version: 0.5.9 Wanting a more clean booting experience with macOS without all that verbose text while booting? Well you need a couple things: macOS Decluttering Misc -> Debug Set AppleDebug to False, this will remove boot.efi debugging right at the start of booting. NVRAM -> Add -> 7C436110-AB2A-4BBB-A880-FE41995C9F82: Remove -v from boot-args in your config.plist NVRAM -> Add -> 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14: UIScale 01: Standard resolution 02: HiDPI (generally required for FileVault to function correctly on smaller displays) UEFI -> Output: TextRenderer set toBuiltinGraphics Resolution: set to Max for best results Optionally can specify resolution: WxH@Bpp (e.g. 1920x1080@32) or WxH (e.g. 1920x1080) ProvideConsoleGop set to True If still having issues, see Configuration.pdf for all possible options. OpenCore Decluttering So if you followed closely to this guide during install, you'll likely be running the debug version of OpenCore and a .txt file would be created on each boot. For those who want to remove OpenCore's extra debugging messages and that .txt file generation, see below: Inside your config.plist: Misc -> Debug -> Target: 3 Target is what determines both what is logged and how, see OpenCore Debugging for more values Inside your EFI: Replace the following files with the release versions(if previously using DEBUG versions): EFI/BOOT/ BOOTx64.efi EFI/OC/Bootstrap/ Bootstrap.efi EFI/OC/Drivers/ OpenRuntime.efi EFI/OC/ OpenCore.efi "},"multiboot/bootstrap.html":{"url":"multiboot/bootstrap.html","title":"Setting up Bootstrap.efi","keywords":"","body":" Last modified: Fri Jul 10 2020 21:28:40 GMT+0000 (Coordinated Universal Time) Using Bootstrap.efi So with OpenCore 0.5.8 and newer, we get a neat little file inside our EFI/OC/Bootstrap folder called Bootstrap.efi. What this allows us to do is add OpenCore to our motherboard's boot menu and prevent issues where either Windows or Linux try to overwrite the BOOTx64.efi file which can happen during updates and completely delete any way of booting OpenCore. Preparation So to start we're gonna need the following: OpenCore 0.5.8 or newer Verify you have EFI/OC/Bootstrap/Bootstrap.efi config.plist settings: Misc -> Security -> BootProtect -> Bootstrap UEFI -> Quirks -> RequestBootVarRouting -> True OpenShell Bundled with OpenCore Remember to add this to both EFI/OC/Tools and config.plist -> Misc -> Tools This is mainly for troubleshooting Booting So once you've got the prerequisites out of the way, we're ready to boot! So what the first boot with these settings enabled is create a new boot option in our BIOS(Boot9696) and every boot after this will update the entry making sure it's correct. This now allows us to either remove BOOTx64.efi or not worry about it when other OSes overwrite this file. If no new boot option is created, you can go down and follow the troubleshooting steps on manually adding it. But triple check the above settings are correct on your system. Troubleshooting This is mainly as a mini-guide in case BootProtect doesn't work or you'd like to do it manually. Verify Bootstrap entry was applied Removing Bootstrap entry from BIOS Verify Bootstrap entry was applied For those wanting to verify that the entry was applied in OpenCore, enabling logging(see OpenCore Debugging) and check for entries similar to these: OCB: Have existing option 1, valid 1 OCB: Boot order has first option as the default option Removing Bootstrap entry from BIOS Because the Bootstrap entry is a protected entry when resetting NVRAM, you'll need to set certain settings: Misc -> Security -> AllowNvramReset -> true Misc -> Security -> BootProtect -> None Once these 2 are set in your config.plist, you can next reboot into the OpenCore picker and select the Reset NVRAM entry "},"multiboot/bootcamp.html":{"url":"multiboot/bootcamp.html","title":"Installing BootCamp","keywords":"","body":" Last modified: Fri Jul 10 2020 21:28:40 GMT+0000 (Coordinated Universal Time) Installing and using BootCamp utilities So a neat feature of OpenCore is the ability to avoid the BIOS entirely and use Startup disk solely for multiboot. Problem comes in when we try to boot windows and have no way of setting the boot option back to macOS. That's where the BootCamp utilities come in. Note: This guide will not cover the creation of the Windows installer, only the installation of BootCamp drivers. Example of Windows installer creation: Build a Bootable Windows ISO Reminder: Windows MUST be GPT/GUID based, OpenCore will not boot legacy installs Note 2: Using BootCamp utilities from macOS will erase the EFI/BOOT/BOOTx64.efi file on your EFI, which is needed for booting OpenCore. And OpenCore itself does not support MBR based installs so the utility is useless to us Preparations To start we'll need the following: Windows already installed MUST be UEFI/GPT based Brigadier To download the BootCamp drivers SMBIOS injection enabled As the drivers have a SMBIOS check Setup Bootstrap.efi Not required but can help alleviate headaches when Windows erases the BOOTx64.efi OpenCore uses Installation To install, it's as simple as grabbing Brigadier and running either Brigadier.bat for Windows or Brigadier.command for macOS. If the SMBIOS you're currently using either has BootCamp issues or want to download for another SMBIOS, you can add -- model{SMBIOS} to the end: path/to/Brigadier --model MacPro7,1 Note: Older versions of the BootCamp installer(6.0) do not support APFS, you'll need to either choose a newer SMBIOS that would have it bundled(ie. iMac 19,1) or after installation update your bootcamp software. See below for more details on troubleshooting: Windows Startup Disk can't see APFS drives Next you will find our bootcamp drivers under either: Windows: \\Users\\{Username}\\bootcamp-{filename}\\BootCamp macOS: /Users/{Username}/BootCamp-{filename}/WindowsSupport.dmg macOS users will next need to expand WindowsSupport.dmg and place it somewhere Windows can get. Next navigate to the bootcamp-{filename}\\BootCamp folder and run the Setup.exe: Once all is finished, you now have BootCamp switching! There should be a little BootCamp icon in you tray now that you can select which drive to boot to. Note: For those no needing the extra drivers BootCamp provides, you can delete the following: $WinPEDriver$: DO NOT delete the folder itself, just the drivers inside Apple Wifi card users will want to keep the following: $WinPEDriver$/BroadcomWireless $WinPEDriver$/BroadcomBluetooth $WinPEDriver$/AppleBluetoothBroadcom BootCamp/Drivers/... DO NOT delete BootCamp/Drivers/Apple Apple Wifi card users will want to keep the following: BootCamp/Drivers/Broadcom/BroadcomBluetooth Troubleshooting Can't find Windows/BootCamp drive in picker \"You can't change the startup disk to the selected disk\" error Booting Windows results in BlueScreen or Linux crashes Booting Windows error: OCB: StartImage failed - Already started Windows Startup Disk can't see APFS drives Can't find Windows/BootCamp drive in picker So with OpenCore, we have to note that legacy Windows installs are not supported, only UEFI. Most installs now are UEFI based but those made by BootCamp Assistant in macOS are legacy based, so you'll have to find other means to make an installer(Google's your friend). This also means MasterBootRecord/Hybrid partitions are also broken so you'll need to format the drive you want to install onto with DiskUtility. Now to get onto troubleshooting: Make sure Misc -> Security -> ScanPolicy is set to 0 to show all drives If Windows and OpenCore's boot loaders are on the same drive, you'll need to add a BlessOverride entry: Misc -> BlessOverride -> \\EFI\\Microsoft\\Boot\\bootmgfw.efi Note: As of OpenCore 0.5.9, this no longer needs to be specified. OpenCore should pick up on this entry automatically \"You can't change the startup disk to the selected disk\" error This is commonly caused by either: 3rd Party NTFS Drivers(ie. Paragon) Irregular partition setup of the Windows drive, specifically that the EFI is not the first partition. To fix the former, either disable or uninstall these tools. To fix the latter, we need to enable this quirk: PlatformInfo -> Generic -> AdviseWindows -> True Booting Windows results in BlueScreen or Linux crashes This is due to alignment issues, make sure SyncRuntimePermissions is enabled on firmwares supporting MATs. Check your logs whether your firmware supports Memory Attribute Tables(generally seen on 2018 firmwares and newer) For Z390 and newer motherboards, you'll also want to enable ProtectUefiServices to ensure OpenCore's patches are applying correctly. If your firmware is quite old(generally 2013 and older), you'll want to enable ProtectMemoryRegions. Due to the variations of firmwares from vendor to vendor, you'll need to play around with the combination of these 3 quirks and see which works best. Common Windows error code: 0xc000000d Booting Windows error: OCB: StartImage failed - Already started This is due to OpenCore getting confused when trying to boot Windows and accidentally thinking it's booting OpenCore. This can be avoided by either move Windows to it's own drive or adding a custom drive path under BlessOverride. See Configuration.pdf and Can't find Windows/BootCamp drive in picker entry for more details. Windows Startup Disk can't see APFS drives Outdated BootCamp drivers(generally ver 6.0 will come with brigadier, BootCamp Utility in macOS provides newer version like ver 6.1). You can try to alleviate these issues by either updating to the newest release with Apple's software updater or selecting a newer SMBIOS from brigadier(ie. --model iMac19,1) and when running brigadier. For the latter, you'll need to run the following(replace filename.msi with the BootCamp installation msi): msiexec.exe /x \"c:\\filename.msi\" "},"misc/rtc.html":{"url":"misc/rtc.html","title":"Fixing RTC","keywords":"","body":" Last modified: Fri Jul 10 2020 21:28:40 GMT+0000 (Coordinated Universal Time) Fixing RTC write issues TO-DO: Go into more detail about rtcfx_exclude, feel it's a little rushed What this section attempts to teach is how to resolve RTC(CMOS) issues on reboot/wake with certain machines. Most commonly looking like the image below: The reason that these CMOS and safe mode errors happen is due to AppleRTC writing to certain areas that are not supported by the hardware properly and thus resulting in panics and errors. To get around this, we've commonly blocked out all RTC writes with these types of patches but they're not ideal for many reasons including both breaking Windows and linux and disabling potential supported regions like for power management. So with OpenCore, we've got a few options to choose: Patch AppleRTC from writing to specific regions They may break in future OS updates Much more difficult for the end user to patch Omit bad regions from being writable They may break in future firmware updates Much easier for the end user to patch The former is actually already integrated into OpenCore with the DisableRtcChecksum quirk, but has the downfall of only blocking regions 0x58-0x59 and only working in the kernel level. Best way to know if this option is best, enable it and try. If this doesn't work, disable as it's an unnecessary patch. With the latter, we're able to block very specific regions of our choice that match our exact model. And we're able to do this both in the kernel level and firmware aiding with hibernation support. This however will requires much more time and RTCMemoryFixup. Finding our bad RTC region For the rest of this guide, we're going to assume you've tested option 1(DisableRtcChecksum) and it didn't work. To get started, we should first introduce a few ideas: RTC will generally have regions spanning from 0 to 255 These regions will be in the hexadecimal counting system so in reality will be 0x00-0xFF To omit bad regions, we use the boot-arg rtcfx_exclude=00-FF Replace 00-FF with your bad region Reminder boot-args is located under NVRAM -> Add in your config.plist This will also require you to have RTCMemoryFixup in your config.plist and EFI/OC/Kexts folder. To find the bad region, we'll want to split out search into chunks Regarding splitting out chunks, what we'll be doing is omitting chunks of RTC regions until we've narrowed down far enough to the exact spot that's bad. You can see the below on how to start: Split 0x00-0xFF into 2 0x00-0x7F and 0x80-0xFF Test rtcfx_exclude=00-7F and rtcfx_exclude=80-FF After testing which regions is bad, shrink even more Assuming our bad region was within 0x80-0xFF, we'd next split that into 2: 0x80-0xBF and 0xC0-0xFF And we go on with this pattern until we've narrowed down the bad region. Note that you will need to reboot each time to test if you're still getting CMOS/Safe-mode errors Also note that the final bad spot will be a range and not a singular spot. ie. rtcfx_exclude=85-86 instead of one singular value Pro tip: To find a value in between 2 regions, I recommend first converting from hexadecimal to decimal, then run the below equation: (x + y) / 2 Now lets try to use this with step 1 from earlier: 0x00-0xFF -> 0-255 -> (0 + 255) / 2 = 127.5 Now with 127.5, we'll round up and down to get ourselves an end and a start value: 0-127 -> 0x00-0x7F 128-255 -> 0x80-0xFF And hopefully this can help better understand how we got our values from step 1. Making the blacklist more permanent Once you've found the bad RTC region, we can now finally add it to OpenCore itself and allow this region to also be blacklisted at the firmware level. For this, open up your config.plist and head to the NVRAM -> Add section. Here under the 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102 GUID, we'll want to add a new entry called rtc-blacklist Next we'll want to add our bad RTC region as an array, so rtcfx_exclude=85-86 will become rtc-blacklist | Data | 8586. This will also work with longer ranges such as 85-89 and such. Remember to remove the boot-arg once you're set rtc-blacklist Next ensure you have NVRAM -> Block also set as NVRAM variables will not be overrided by OpenCore unless explicitly told so. And finally, set AppleRtcRam under UEFI -> ProtocolOverrides to true. This will block that region from being written to at the firmware level. Once all this is done, you should have something similar to below: "},"misc/msr-lock.html":{"url":"misc/msr-lock.html","title":"Fixing CFG Lock","keywords":"","body":" Last modified: Fri Jul 10 2020 21:28:40 GMT+0000 (Coordinated Universal Time) Fixing CFG Lock Supported version: 0.5.9 Do note that this is only recommended for users who have already installed macOS, for users who are installing for the first time enable AppleCpuPmCfgLock and AppleXcpmCfgLock under Kernel -> Quirks What is CFG-Lock CFG-Lock is a setting in your BIOS that allows for a specific register(in this case the MSR 0xE2) to be written to. By default, most motherboards lock this variable with many even hiding the option outright in the GUI. And why we care about it is that macOS actually wants to write to this variable, and not just one part of macOS. Instead both the Kernel(XNU) and AppleIntelPowerManagement want this register. So to fix it we have 2 options: Patch macOS to work with our hardware This creates instability and unnecessary patching for many The 2 patches we use for this: AppleCpuPmCfgLock for AppleIntelPowerManagement.kext AppleXcpmCfgLock for the Kernel(XNU) Patch our firmware to support MSR E2 write Very much preferred, as avoids patching allowing for greater flexibility regarding stability and OS upgrades Note: Penyrn based machines actually don't need to worry about unlocking this register Disabling CFG Lock So you've installed macOS but you're using those pesky CFG-Lock patches that we want to get rid of, well to do this is fairly simple. You'll need the following: Inside your EFI/OC/Tools folder and config.plist: VerifyMsrE2 Modified GRUB Shell And some apps to help us out: UEFITool (Make sure it's UEFITool and not UEFIExtrac) Universal-IFR-Extractor And don't forget to disable the following from your config.plist under Kernel -> Quirks: AppleCpuPmCfgLock AppleXcpmCfgLock And the final part, grabbing your BIOS from the vendors' website. Now the fun part! Checking if CFG-Lock can be turned off Boot OpenCore and select the VerifyMsrE2 option in the picker. This tool will tell you whether your BIOS supports CFG-Lock and if it can be unlocked. Turning off CFG-Lock manually Open your firmware with UEFITool and then find CFG Lock as a Unicode string. If nothing pops up then your firmware doesn't support CFG Lock, otherwise continue on. You'll find that this string is found within a Setup folder, right-click and export as Setup.bin Open your setup file with ifrextract and export as a .txt file with terminal: path/to/ifrextract path/to/Setup.bin path/to/Setup.txt Open the text file and search for CFG Lock, VarStoreInfo (VarOffset/VarName): and note the offset right after it(ie: 0x5A4) Run the Modified GRUB Shell and paste the following where 0x5A4 is replaced with your value: setup_var 0x5A4 0x00 Do note that variable offsets are unique not just to each motherboard but even to its firmware version. Never try to use an offset without checking. And you're done! Now you'll have correct CPU power management Note: Every time you reset your BIOS you will need to flip this bit again, make sure to write it down with the BIOS version so you know which. "},"misc/nvram.html":{"url":"misc/nvram.html","title":"Emulated NVRAM","keywords":"","body":" Last modified: Fri Jul 10 2020 21:28:40 GMT+0000 (Coordinated Universal Time) Emulated NVRAM Supported version: 0.5.9 So this section is for those who don't have native NVRAM, the most common hardware to have incompatible native NVRAM with macOS are X99 and some X299 series chipsets: X99 X299 For B360, B365, H310, H370, Z390 users, make sure you have SSDT-PMC both under EFI/OC/ACPI and config.plist -> ACPI -> Add. For more info on making and compiling SSDTs, please see Getting started with ACPI Note: 10th gen CPUs do not need this SSDT Cleaning out the Clover gunk So some may not have noticed but Clover may have installed RC scripts into macOS for proper NVRAM emulation. This is an issue as it conflicts with OpenCore's method of emulation. Files to delete: /Volumes/EFI/EFI/CLOVER/drivers64UEFI/EmuVariableUefi-64.efi /Volumes/EFI/nvram.plist /etc/rc.clover.lib /etc/rc.boot.d/10.save_and_rotate_boot_log.local /etc/rc.boot.d/20.mount_ESP.local /etc/rc.boot.d/70.disable_sleep_proxy_client.local.disabled /etc/rc.shutdown.d/80.save_nvram_plist.local​ If folders are empty then delete them as well: /etc/rc.boot.d /etc/rc.shutdown.d​ Verifying if you have working NVRAM To start, open the terminal and run the following one line at a time: sudo -s sudo nvram -c sudo nvram myvar=test exit Now reboot and run this: nvram -p | grep -i myvar If nothing returns then your NVRAM is not working. If a line containing myvar test returns, your NVRAM is working. Note: nvram -c requires SIP to be off, an alternative is to wipe NVRAM at the boot menu. Reminder you'll need Misc -> Security -> AllowNvramReset -> YES Enabling emulated NVRAM (with a nvram.plist) To enable emulated NVRAM, you'll need 3 things set: Within your config.plist: Booter: DisableVariableWrite: set to NO Misc -> Security: ExposeSensitiveData: set to 0x3 NVRAM: LegacyEnable: set to YES LegacyOverwrite set to YES LegacySchema: NVRAM variables set(OpenCore compares these to the variables present in nvram.plist) WriteFlash: set to YES And within your EFI: OpenRuntime.efi driver(this is needed for proper sleep, shutdown and other services to work correctly Now grab the 'LogoutHook.command'(Inside /Utilities/LogoutHook/) and place it somewhere safe (e.g. within your user directory, as shown below): /Users/(your username)/LogoutHook/LogoutHook.command Open up terminal and run the following: sudo defaults write com.apple.loginwindow LogoutHook /Users/(your username)/LogoutHook/LogoutHook.command And voila! You have emulated NVRAM! Do keep in mind this requires the nvram command to support the -x flag for this to work correctly which is unavailable on macOS 10.12 and below. If you are installing macOS 10.12 or earlier, you need to copy nvram.mojave into the same folder as LogoutHook.command, which fixes this by invoking it instead of the system nvram command. Something else to note is that macOS is only able to read nvram.plist but it won't be able to write to nvram.plist unless running the shutdown process. This means running the test above won't work "}}